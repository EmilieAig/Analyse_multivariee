# Rotation de l'ACP Photosynthèse
rotation_photo <- acp_photo$rotation[, 1:n_comp_photo]
# Coefficients pour les variables géographiques originales
# Formule : coef_originaux = Rotation × coef_composantes
coef_geo_originaux <- rotation_geo %*% coef_modele_themes[1:n_comp_geo]
# Coefficients pour les variables photosynthèse originales
coef_photo_originaux <- rotation_photo %*% coef_modele_themes[(n_comp_geo+1):(n_comp_geo+n_comp_photo)]
cat("\n=== TOP 10 VARIABLES GÉOGRAPHIE (en valeur absolue) ===\n")
coef_geo_sorted <- sort(abs(coef_geo_originaux), decreasing = TRUE)
print(head(coef_geo_sorted, 10))
cat("\n=== TOP 10 VARIABLES PHOTOSYNTHÈSE (en valeur absolue) ===\n")
coef_photo_sorted <- sort(abs(coef_photo_originaux), decreasing = TRUE)
print(head(coef_photo_sorted, 10))
# Afficher tous les coefficients si besoin
cat("\n=== TOUS LES COEFFICIENTS GÉOGRAPHIE ===\n")
print(coef_geo_originaux)
cat("\n=== TOUS LES COEFFICIENTS PHOTOSYNTHÈSE ===\n")
print(coef_photo_originaux)
library(dplyr)
# Ouvrir le fichier en précisant les séparateurs
data <- read.csv("Datagenus.csv", sep = ";", dec = ",", header = TRUE)
# Transform all character columns into numerical values
data <- data %>% mutate_if(is.character,~ as.numeric(.))
# Enlever la colonne forest
data <- data %>% select(-forest)
# Données qui contiennent uniquement les variables d'espèces
data_gen <- data %>% select(num_range("gen", 1:27))
treedensity <- rowSums(data_gen) / data$surface
# Calculer les carrés des variables géographiques
var_geo_quanti <- c("lat", "lon", "altitude", "pluvio_yr", paste0("pluvio_", 1:12))
var_geo_carre <- data[, var_geo_quanti]^2
colnames(var_geo_carre) <- paste0(var_geo_quanti, "^2")
# Créer les indicatrices de geology
data$geology <- as.factor(data$geology)
geo_indic <- model.matrix(~ geology - 1, data = data)
# Regrouper toutes les variables explicatives
var_explicatives <- bind_cols(
data %>% select(lat, lon, altitude, pluvio_yr, num_range("pluvio_", 1:12)),  # Variables géographiques
var_geo_carre,                                                               # Leurs carrés
as.data.frame(geo_indic),                                                    # Indicatrices geology
data %>% select(num_range("evi_", 1:23))                                     # EVI
)
# ACP réduite (variables centrées et réduites)
acp <- prcomp(var_explicatives, scale. = TRUE, center = TRUE)
# Résumé de l'ACP
summary(acp)
# Variance expliquée par chaque composante
variance_expliquee <- acp$sdev^2 / sum(acp$sdev^2) * 100
# Afficher les variances expliquées
barplot(variance_expliquee[1:20],
names.arg = 1:20,
xlab = "Composante principale",
ylab = "% de variance expliquée",
main = "Variance expliquée par les composantes principales")
# Variance cumulée
variance_cumulee <- cumsum(variance_expliquee)
# Créer un tableau récapitulatif
recap_acp <- data.frame(
Composante = 1:ncol(var_explicatives),
Variance = acp$sdev^2,
Variance_pct = variance_expliquee,
Variance_cum = variance_cumulee
)
# Afficher les premières composantes
head(recap_acp, 20)
# Récupérer les 3 premières composantes principales
composantes_retenues <- acp$x[, 1:5]
# Créer un data frame avec Y et les composantes
data_regression <- data.frame(
treedensity = treedensity,
PC1 = composantes_retenues[, 1],
PC2 = composantes_retenues[, 2],
PC3 = composantes_retenues[, 3],
PC4 = composantes_retenues[, 4],
PC5 = composantes_retenues[, 5]
)
# Ajuster le modèle linéaire avec les 3 composantes
modele_complet <- lm(treedensity ~ PC1 + PC2 + PC3 + PC4 + PC5, data = data_regression)
# Afficher le résumé du modèle
summary(modele_complet)
Y <- treedensity
Y_chapeau <- fitted(modele_complet)
# Créer le graphique
plot(Y, Y_chapeau,
xlab = "Densité observée (Y)",
ylab = "Densité prédite (Ŷ)",
main = "Valeurs observées vs prédites (R² = 0.204)",
pch = 20,
col = rgb(0, 0, 1, 0.5))
# Ajouter la droite y = x (droite identité)
abline(a = 0, b = 1, col = "red", lwd = 2)
# Ajouter une droite de régression pour voir l'ajustement
abline(lm(Y_chapeau ~ Y), col = "blue", lty = 2, lwd = 2)
legend("topright",
legend = c("Droite identité (y=x)", "Droite de régression"),
col = c("red", "blue"),
lty = c(1, 2),
lwd = 2,
cex = 0.8)
# Calculer quelques statistiques pour le commentaire
correlation_YYchap <- cor(Y, Y_chapeau)
cat("Corrélation entre Y et Ŷ :", round(correlation_YYchap, 4), "\n")
# Les coefficients des composantes dans le modèle (sans l'intercept)
coef_composantes <- coef(modele_complet)[-1]
cat("Coefficients des composantes dans le modèle :\n")
print(coef_composantes)
# La matrice de rotation de l'ACP pour les 3 premières composantes (donne les coefficients des variables originelles dans les composantes)
rotation_matrix <- acp$rotation[, 1:5]
# Calculer les coefficients des variables originelles
coef_originels <- rotation_matrix %*% coef_composantes
# Créer un data frame pour une meilleure visualisation
coef_df <- data.frame(
Variable = rownames(coef_originels),
Coefficient = as.vector(coef_originels)
)
# Trier par valeur absolue décroissante pour voir les plus importantes
coef_df <- coef_df[order(abs(coef_df$Coefficient), decreasing = TRUE), ]
# Afficher tous les coefficients
print(coef_df, row.names = FALSE)
# Afficher les 10 variables les plus influentes
print(head(coef_df, 10), row.names = FALSE)
# Vérifier s'il y a des zéros ou valeurs négatives dans treedensity
cat("=== DIAGNOSTIC DE LA VARIABLE Y ===\n")
cat("Valeur minimale :", min(treedensity), "\n")
cat("Valeur maximale :", max(treedensity), "\n\n")
# Appliquer la transformation log(Y + 1) qui préserve les zéros
# log(0 + 1) = 0, donc les zéros restent à 0
treedensity_log <- log(treedensity + 1)
cat("Après transformation log(Y+1) :\n")
cat("Valeur minimale :", min(treedensity_log), "\n")
cat("Valeur maximale :", max(treedensity_log), "\n\n")
# Refaire la régression avec Y transformé
data_regression_log <- data.frame(
treedensity_log = treedensity_log,
PC1 = composantes_retenues[, 1],
PC2 = composantes_retenues[, 2],
PC3 = composantes_retenues[, 3],
PC4 = composantes_retenues[, 4],
PC5 = composantes_retenues[, 5]
)
modele_log <- lm(treedensity_log ~ PC1 + PC2 + PC3 + PC4 + PC5, data = data_regression_log)
# Afficher le résumé du modèle log
cat("=== MODÈLE AVEC TRANSFORMATION LOG(Y+1) ===\n\n")
summary(modele_log)
# Comparer les deux modèles
cat("\n=== COMPARAISON DES DEUX MODÈLES ===\n")
cat("Modèle original    - R² =", round(summary(modele_complet)$r.squared, 4), "\n")
cat("Modèle log(Y+1)    - R² =", round(summary(modele_log)$r.squared, 4), "\n")
cat("Amélioration du R² :",
round(summary(modele_log)$r.squared - summary(modele_complet)$r.squared, 4), "\n\n")
# Comparaison visuelle des deux modèles
# Préparer les graphiques côte à côte
par(mfrow = c(1, 2))
# GRAPHIQUE 1 : Modèle original
Y <- treedensity
Y_chapeau <- fitted(modele_complet)
plot(Y, Y_chapeau,
xlab = "Densité observée (Y)",
ylab = "Densité prédite (Ŷ)",
main = paste0("Modèle original\nR² = ", round(summary(modele_complet)$r.squared, 3)),
pch = 20,
col = rgb(0, 0, 1, 0.5),
cex.main = 0.9)
abline(a = 0, b = 1, col = "red", lwd = 2)
abline(lm(Y_chapeau ~ Y), col = "blue", lty = 2, lwd = 2)
# GRAPHIQUE 2 : Modèle avec log
Y_log <- treedensity_log
Y_chapeau_log <- fitted(modele_log)
plot(Y_log, Y_chapeau_log,
xlab = "log(Densité + 1) observé",
ylab = "log(Densité + 1) prédit",
main = paste0("Modèle log(Y+1)\nR² = ", round(summary(modele_log)$r.squared, 3)),
pch = 20,
col = rgb(0, 0.6, 0, 0.5),
cex.main = 0.9)
abline(a = 0, b = 1, col = "red", lwd = 2)
abline(lm(Y_chapeau_log ~ Y_log), col = "darkgreen", lty = 2, lwd = 2)
# Réinitialiser les paramètres graphiques
par(mfrow = c(1, 1))
# Calculer les corrélations pour comparer
cor_original <- cor(Y, Y_chapeau)
cor_log <- cor(Y_log, Y_chapeau_log)
cat("\n=== CORRÉLATIONS Y vs Ŷ ===\n")
cat("Modèle original :", round(cor_original, 4), "\n")
cat("Modèle log      :", round(cor_log, 4), "\n")
# === THÈME GÉOGRAPHIE ===
# Variables géographiques quantitatives + leurs carrés + indicatrices géologie
var_geo <- bind_cols(
data %>% select(lat, lon, altitude, pluvio_yr, num_range("pluvio_", 1:12)),  # Variables géo
var_geo_carre,                                                               # Leurs carrés
as.data.frame(geo_indic)                                                     # Indicatrices geology
)
cat("=== THÈME GÉOGRAPHIE ===\n")
cat("Nombre de variables :", ncol(var_geo), "\n")
cat("Variables :", colnames(var_geo), "\n\n")
# === THÈME PHOTOSYNTHÈSE ===
# Tous les indices EVI
var_photo <- data %>% select(num_range("evi_", 1:23))
cat("=== THÈME PHOTOSYNTHÈSE ===\n")
cat("Nombre de variables :", ncol(var_photo), "\n")
cat("Variables :", colnames(var_photo), "\n\n")
# === ACP THÈME GÉOGRAPHIE ===
# ACP réduite sur les variables géographiques
acp_geo <- prcomp(var_geo, scale. = TRUE, center = TRUE)
# Résumé de l'ACP géographie
cat("=== ACP THÈME GÉOGRAPHIE ===\n\n")
summary(acp_geo)
# Variance expliquée par composante
variance_geo <- acp_geo$sdev^2 / sum(acp_geo$sdev^2) * 100
# Graphique de la variance expliquée
barplot(variance_geo[1:15],
names.arg = 1:15,
xlab = "Composante principale",
ylab = "% de variance expliquée",
main = "ACP Géographie - Variance expliquée",
col = "steelblue")
# Variance cumulée
variance_cum_geo <- cumsum(variance_geo)
# Tableau récapitulatif
recap_geo <- data.frame(
Composante = 1:length(variance_geo),
Variance = acp_geo$sdev^2,
Variance_pct = variance_geo,
Variance_cum = variance_cum_geo
)
cat("\n")
print(head(recap_geo, 10))
cat("\n=== CHOIX DU NOMBRE DE COMPOSANTES GÉOGRAPHIE ===\n")
cat("Regardez le graphique et le tableau pour décider combien de composantes retenir.\n")
cat("Critères : saut dans la variance expliquée, variance cumulée > 70-80%\n\n")
# === ACP THÈME PHOTOSYNTHÈSE ===
# ACP réduite sur les variables de photosynthèse (EVI)
acp_photo <- prcomp(var_photo, scale. = TRUE, center = TRUE)
# Résumé de l'ACP photosynthèse
cat("=== ACP THÈME PHOTOSYNTHÈSE ===\n\n")
summary(acp_photo)
# Variance expliquée par composante
variance_photo <- acp_photo$sdev^2 / sum(acp_photo$sdev^2) * 100
# Graphique de la variance expliquée
barplot(variance_photo[1:15],
names.arg = 1:15,
xlab = "Composante principale",
ylab = "% de variance expliquée",
main = "ACP Photosynthèse - Variance expliquée",
col = "darkgreen")
# Variance cumulée
variance_cum_photo <- cumsum(variance_photo)
# Tableau récapitulatif
recap_photo <- data.frame(
Composante = 1:length(variance_photo),
Variance = acp_photo$sdev^2,
Variance_pct = variance_photo,
Variance_cum = variance_cum_photo
)
cat("\n")
print(head(recap_photo, 10))
cat("\n=== CHOIX DU NOMBRE DE COMPOSANTES PHOTOSYNTHÈSE ===\n")
cat("Regardez le graphique et le tableau pour décider combien de composantes retenir.\n\n")
# ==============================================================================
# QUESTION 3.c) - Retrouver les coefficients des variables originelles
# ==============================================================================
cat("\n--- 3.c) Coefficients des variables originelles ---\n")
# Coefficients des composantes dans le modèle
coef_modele_themes <- coef(modele_themes)[-1]  # Enlever l'intercept
cat("\nCoefficients des composantes dans le modèle :\n")
print(coef_modele_themes)
# Rotation de l'ACP Géographie (= loadings)
rotation_geo <- acp_geo$rotation[, 1:n_comp_geo]
# Rotation de l'ACP Photosynthèse
rotation_photo <- acp_photo$rotation[, 1:n_comp_photo]
# Coefficients pour les variables géographiques originales
# Formule : coef_originaux = Rotation × coef_composantes
coef_geo_originaux <- rotation_geo %*% coef_modele_themes[1:n_comp_geo]
# Coefficients pour les variables photosynthèse originales
coef_photo_originaux <- rotation_photo %*% coef_modele_themes[(n_comp_geo+1):(n_comp_geo+n_comp_photo)]
cat("\n=== TOP 10 VARIABLES GÉOGRAPHIE (en valeur absolue) ===\n")
coef_geo_sorted <- sort(abs(coef_geo_originaux), decreasing = TRUE)
print(head(coef_geo_sorted, 10))
cat("\n=== TOP 10 VARIABLES PHOTOSYNTHÈSE (en valeur absolue) ===\n")
coef_photo_sorted <- sort(abs(coef_photo_originaux), decreasing = TRUE)
print(head(coef_photo_sorted, 10))
# Afficher tous les coefficients si besoin
cat("\n=== TOUS LES COEFFICIENTS GÉOGRAPHIE ===\n")
print(coef_geo_originaux)
cat("\n=== TOUS LES COEFFICIENTS PHOTOSYNTHÈSE ===\n")
print(coef_photo_originaux)
cat("\n--- 3.c) Coefficients des variables originelles ---\n")
# Coefficients des composantes dans le modèle
coef_modele_themes <- coef(modele_themes)[-1]  # Enlever l'intercept
cat("\nCoefficients des composantes dans le modèle :\n")
print(coef_modele_themes)
# Rotation de l'ACP Géographie (= loadings)
rotation_geo <- acp_geo$rotation[, 1:n_comp_geo]
# Rotation de l'ACP Photosynthèse
rotation_photo <- acp_photo$rotation[, 1:n_comp_photo]
# Coefficients pour les variables géographiques originales
# Formule : coef_originaux = Rotation × coef_composantes
coef_geo_originaux <- rotation_geo %*% coef_modele_themes[1:n_comp_geo]
# Coefficients pour les variables photosynthèse originales
coef_photo_originaux <- rotation_photo %*% coef_modele_themes[(n_comp_geo+1):(n_comp_geo+n_comp_photo)]
cat("\n=== TOP 10 VARIABLES GÉOGRAPHIE (en valeur absolue) ===\n")
coef_geo_sorted <- sort(abs(coef_geo_originaux), decreasing = TRUE)
print(head(coef_geo_sorted, 10))
cat("\n=== TOP 10 VARIABLES PHOTOSYNTHÈSE (en valeur absolue) ===\n")
coef_photo_sorted <- sort(abs(coef_photo_originaux), decreasing = TRUE)
print(head(coef_photo_sorted, 10))
# Sauvegarder pour la synthèse finale
coef_themes_tous <- c(coef_geo_originaux, coef_photo_originaux)
# === 3.b) MODÉLISATION AVEC LES COMPOSANTES DES DEUX THÈMES ===
# Définir le nombre de composantes retenues pour chaque thème
n_comp_geo <- 3    # 3 composantes pour Géographie
n_comp_photo <- 3  # 3 composantes pour Photosynthèse
# Récupérer les composantes principales de chaque ACP
comp_geo <- acp_geo$x[, 1:n_comp_geo]
comp_photo <- acp_photo$x[, 1:n_comp_photo]
# Créer un data frame avec Y transformé et TOUTES les composantes
# On réunit les composantes des deux thèmes
data_regression_themes <- data.frame(
treedensity_log = treedensity_log,  # On utilise la transformation log(Y+1)
# Composantes Géographie
PC_geo1 = comp_geo[, 1],
PC_geo2 = comp_geo[, 2],
PC_geo3 = comp_geo[, 3],
# Composantes Photosynthèse
PC_photo1 = comp_photo[, 1],
PC_photo2 = comp_photo[, 2],
PC_photo3 = comp_photo[, 3]
)
# Ajuster le modèle linéaire avec toutes les composantes
modele_themes <- lm(treedensity_log ~ PC_geo1 + PC_geo2 + PC_geo3 +
PC_photo1 + PC_photo2 + PC_photo3,
data = data_regression_themes)
# Afficher le résumé du modèle
cat("=== MODÈLE AVEC COMPOSANTES PAR THÈMES ===\n\n")
summary(modele_themes)
# Comparer avec le modèle de la question 2
cat("\n=== COMPARAISON DES MODÈLES ===\n")
cat("Q2 - ACP globale     : R² =", round(summary(modele_log)$r.squared, 4), "\n")
cat("Q3 - ACP par thèmes  : R² =", round(summary(modele_themes)$r.squared, 4), "\n")
cat("Différence           :",
round(summary(modele_themes)$r.squared - summary(modele_log)$r.squared, 4), "\n\n")
# Construire le graphe Y observé vs Y prédit
Y_log <- treedensity_log
Y_chapeau_themes <- fitted(modele_themes)
# Créer le graphique
plot(Y_log, Y_chapeau_themes,
xlab = "log(Densité + 1) observé",
ylab = "log(Densité + 1) prédit",
main = paste0("Modèle ACP par thèmes\nR² = ", round(summary(modele_themes)$r.squared, 4)),
pch = 20,
col = rgb(0.8, 0.2, 0, 0.5),
cex.main = 0.9)
# Ajouter la droite identité (y = x)
abline(a = 0, b = 1, col = "red", lwd = 2)
# Ajouter la droite de régression
abline(lm(Y_chapeau_themes ~ Y_log), col = "darkorange", lty = 2, lwd = 2)
legend("topleft",
legend = c("Droite identité (y=x)", "Droite de régression"),
col = c("red", "darkorange"),
lty = c(1, 2),
lwd = 2,
cex = 0.8)
# Calculer la corrélation
correlation_themes <- cor(Y_log, Y_chapeau_themes)
cat("\nCorrélation entre Y et Ŷ :", round(correlation_themes, 4), "\n")
# === 3.c) COEFFICIENTS DES VARIABLES ORIGINELLES ===
cat("\n=== QUESTION 3.c - COEFFICIENTS DES VARIABLES ORIGINELLES ===\n\n")
# Récupérer les coefficients des composantes dans le modèle (sans l'intercept)
coef_modele_themes <- coef(modele_themes)[-1]
cat("Coefficients des composantes dans le modèle :\n")
print(coef_modele_themes)
# Matrices de rotation (loadings) pour chaque thème
rotation_geo <- acp_geo$rotation[, 1:n_comp_geo]
rotation_photo <- acp_photo$rotation[, 1:n_comp_photo]
# Calculer les coefficients pour les variables GÉOGRAPHIE originales
# Formule : β_originaux = Rotation × β_composantes
coef_geo_originaux <- rotation_geo %*% coef_modele_themes[1:n_comp_geo]
# Calculer les coefficients pour les variables PHOTOSYNTHÈSE originales
coef_photo_originaux <- rotation_photo %*% coef_modele_themes[(n_comp_geo+1):(n_comp_geo+n_comp_photo)]
# Créer des data frames pour une meilleure visualisation
coef_geo_df <- data.frame(
Variable = rownames(coef_geo_originaux),
Coefficient = as.vector(coef_geo_originaux)
)
coef_photo_df <- data.frame(
Variable = rownames(coef_photo_originaux),
Coefficient = as.vector(coef_photo_originaux)
)
# Trier par valeur absolue décroissante
coef_geo_df <- coef_geo_df[order(abs(coef_geo_df$Coefficient), decreasing = TRUE), ]
coef_photo_df <- coef_photo_df[order(abs(coef_photo_df$Coefficient), decreasing = TRUE), ]
cat("\n=== TOP 10 VARIABLES GÉOGRAPHIE LES PLUS INFLUENTES ===\n")
print(head(coef_geo_df, 10), row.names = FALSE)
cat("\n=== TOP 10 VARIABLES PHOTOSYNTHÈSE LES PLUS INFLUENTES ===\n")
print(head(coef_photo_df, 10), row.names = FALSE)
# Combiner tous les coefficients pour la synthèse finale (Question 6)
coef_themes_tous <- rbind(
data.frame(Variable = coef_geo_df$Variable, Coefficient = coef_geo_df$Coefficient, Theme = "Géographie"),
data.frame(Variable = coef_photo_df$Variable, Coefficient = coef_photo_df$Coefficient, Theme = "Photosynthèse")
)
cat("\n=== VARIABLES LES PLUS INFLUENTES (TOUS THÈMES CONFONDUS) ===\n")
coef_themes_tous_sorted <- coef_themes_tous[order(abs(coef_themes_tous$Coefficient), decreasing = TRUE), ]
print(head(coef_themes_tous_sorted, 15), row.names = FALSE)
# === 3.d) TRANSFORMATION LOGARITHMIQUE ===
cat("\n=== QUESTION 3.d - TRANSFORMATION LOGARITHMIQUE ===\n\n")
cat("Comme pour la question 2, nous avons utilisé la transformation log(Y+1)\n")
cat("sur la variable dépendante dès le départ de la question 3.\n\n")
cat("Raisons de cette transformation :\n")
cat("1. Correction de la linéarité : améliore la relation linéaire entre Y et les prédicteurs\n")
cat("2. Stabilisation de la variance : réduit l'hétéroscédasticité des résidus\n")
cat("3. Préservation des zéros : log(0+1) = 0, donc les parcelles sans arbres restent à 0\n\n")
cat("Résultats avec transformation log(Y+1) :\n")
cat("- R² = ", round(summary(modele_themes)$r.squared, 4), "\n")
cat("- Erreur standard résiduelle = ", round(summary(modele_themes)$sigma, 4), "\n\n")
cat("La transformation logarithmique est donc retenue pour ce modèle.\n")
# Préparer les données : X = var_explicatives, Y = treedensity_log
# Important : on utilise la transformation log(Y+1)
X <- as.matrix(var_explicatives)
Y <- treedensity_log
# Régression PLS avec validation croisée (10-fold cross-validation)
# On teste jusqu'à 20 composantes maximum
set.seed(123)  # Pour la reproductibilité
pls_model <- plsr(Y ~ X,
ncomp = 20,              # Nombre max de composantes à tester
scale = TRUE,             # Centrer et réduire les variables
validation = "CV",        # Validation croisée
segments = 10)            # 10-fold CV
# Résumé du modèle
cat("\n=== RÉSUMÉ DU MODÈLE PLS ===\n")
summary(pls_model)
# Afficher les erreurs de prédiction (PRESS) pour chaque nombre de composantes
cat("\n=== ERREUR DE VALIDATION CROISÉE (PRESS) ===\n")
press_values <- pls_model$validation$PRESS
print(data.frame(
Composantes = 0:20,
PRESS = press_values
))
# Graphique des erreurs de validation croisée
par(mfrow = c(1, 2))
# Graphique 1 : PRESS en fonction du nombre de composantes
plot(0:20, press_values,
type = "b",
xlab = "Nombre de composantes",
ylab = "PRESS (erreur de prédiction)",
main = "Validation croisée PLS",
col = "blue",
pch = 19)
grid()
# Graphique 2 : R² en fonction du nombre de composantes
r2_values <- R2(pls_model)$val
plot(1:20, r2_values[2, 1, ],  # R² de validation croisée
type = "b",
xlab = "Nombre de composantes",
ylab = "R² (validation croisée)",
main = "R² en fonction du nombre de composantes",
col = "darkgreen",
pch = 19)
grid()
par(mfrow = c(1, 1))
# Trouver le nombre optimal de composantes (minimum de PRESS)
optimal_ncomp <- which.min(press_values) - 1  # -1 car l'index commence à 0
cat("\n=== NOMBRE OPTIMAL DE COMPOSANTES ===\n")
cat("Nombre de composantes minimisant PRESS :", optimal_ncomp, "\n")
cat("PRESS minimal :", min(press_values), "\n\n")
# Ajuster le modèle final avec le nombre optimal de composantes
pls_final <- plsr(Y ~ X,
ncomp = optimal_ncomp,
scale = TRUE)
# Résumé du modèle final
cat("\n=== MODÈLE PLS FINAL ===\n")
cat("Nombre de composantes retenues :", optimal_ncomp, "\n")
summary(pls_final)
# Calculer le R² du modèle final
Y_pred_pls <- predict(pls_final, ncomp = optimal_ncomp)
r2_pls <- cor(Y, Y_pred_pls)^2
cat("\nR² du modèle PLS final :", round(r2_pls, 4), "\n")
library(dplyr)
library(pls)
library(dplyr)
library(pls)
# Préparer les données : X = var_explicatives, Y = treedensity_log
# Important : on utilise la transformation log(Y+1)
X <- as.matrix(var_explicatives)
Y <- treedensity_log
# Régression PLS avec validation croisée (10-fold cross-validation)
# On teste jusqu'à 20 composantes maximum
set.seed(123)  # Pour la reproductibilité
pls_model <- plsr(Y ~ X,
ncomp = 20,              # Nombre max de composantes à tester
scale = TRUE,             # Centrer et réduire les variables
validation = "CV",        # Validation croisée
segments = 10)            # 10-fold CV
# Résumé du modèle
cat("\n=== RÉSUMÉ DU MODÈLE PLS ===\n")
summary(pls_model)
# Afficher les erreurs de prédiction (PRESS) pour chaque nombre de composantes
cat("\n=== ERREUR DE VALIDATION CROISÉE (PRESS) ===\n")
press_values <- pls_model$validation$PRESS
print(data.frame(
Composantes = 0:20,
PRESS = press_values
))
# Graphique des erreurs de validation croisée
par(mfrow = c(1, 2))
# Graphique 1 : PRESS en fonction du nombre de composantes
plot(0:20, press_values,
type = "b",
xlab = "Nombre de composantes",
ylab = "PRESS (erreur de prédiction)",
main = "Validation croisée PLS",
col = "blue",
pch = 19)
